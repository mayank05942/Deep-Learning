# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QfMS7OAnjRfbAnLQvpHl4OeUE2_XS82-
"""

import sklearn
import pandas as pd
import torch
from sklearn.model_selection import train_test_split
import torch.nn.functional as F
import torch.nn as nn
from torch import optim
from sklearn.metrics import accuracy_score, precision_score, recall_score
import time
from torch.autograd import Variable

class FFNetwork(nn.Module):

  def __init__(self):
    super().__init__()
    #torch.manual.seed(0)
    self.net = nn.Sequential(
        nn.Linear(4,100),
        nn.Sigmoid(),
        nn.Linear(100,3),
        nn.Softmax(dim = 1)
    )

  def forward(self,X):
    return self.net(X)

def fit(x,y,model,opt,loss_fn,epochs = 10000):

  for _ in range(epochs):
    loss = loss_fn(model(x),y)

    loss.backward()
    opt.step()
    opt.zero_grad()
  
  return loss.item()

import sklearn
from sklearn import datasets
iris = datasets.load_iris()
X = iris.data
Y = iris.target
Y

X_train, X_val, Y_train, Y_val = train_test_split(X, Y, stratify=Y, random_state=0)
print(X_train.shape, X_val.shape, Y.shape)

#X_train, Y_train, X_val, Y_val = map(torch.tensor, (X_train, Y_train, X_val, Y_val))

X_train = Variable(torch.Tensor(X_train).float())
X_val = Variable(torch.Tensor(X_val).float())
Y_train = Variable(torch.Tensor(Y_train).long())
Y_val = Variable(torch.Tensor(Y_val).long())

device = torch.device("cpu")

X_train=X_train.to(device)
Y_train=Y_train.to(device)
fn = FFNetwork()

fn.to(device)
tic = time.time()
loss_fn = nn.CrossEntropyLoss()
opt = optim.SGD(fn.parameters(),lr = 0.01)
print('Final loss', fit(X_train, Y_train, fn, opt, loss_fn))
toc = time.time()
print('Time taken', toc - tic)

pred_val  = fn(X_val)
_, pred_ans = torch.max(pred_val, 1)
print(Y_val)
pred_ans

print("Accuracy_Score",accuracy_score(pred_ans.data,Y_val.data))